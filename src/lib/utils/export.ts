import type { VendorScore, Requirement, Evidence } from '@/lib/scoring/types';

interface ExportOptions {
  vendorScores: VendorScore[];
  requirements: Requirement[];
  evidence: Evidence[];
  customWeights: Record<string, number>;
}

export function generateMarkdownReport({
  vendorScores,
  requirements,
  evidence,
  customWeights,
}: ExportOptions): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];
  const winner = vendorScores[0];

  lines.push('# Vendor Evaluation Report: LLM Ops Tools');
  lines.push('');
  lines.push(`> Generated by SignalCore on ${timestamp}`);
  lines.push('');

  // Executive Summary
  lines.push('## Executive Summary');
  lines.push('');
  lines.push(
    `This report compares **${vendorScores.length} vendors** across **${requirements.length} requirements** using evidence-based scoring.`
  );
  lines.push('');
  if (winner) {
    lines.push(
      `**Top Pick: ${winner.vendor.name}** with an overall score of **${winner.totalScore.toFixed(1)}/10** (${winner.confidence} confidence).`
    );
  }
  lines.push('');

  // Rankings
  lines.push('## Overall Rankings');
  lines.push('');
  lines.push('| Rank | Vendor | Score | Confidence |');
  lines.push('|------|--------|-------|------------|');
  vendorScores.forEach((vs, i) => {
    lines.push(
      `| ${i + 1} | ${vs.vendor.name} | ${vs.totalScore.toFixed(1)}/10 | ${vs.confidence} |`
    );
  });
  lines.push('');

  // Comparison Table
  lines.push('## Detailed Comparison');
  lines.push('');
  const headerCols = ['Requirement', ...vendorScores.map((vs) => vs.vendor.name)];
  lines.push('| ' + headerCols.join(' | ') + ' |');
  lines.push('|' + headerCols.map(() => '---').join('|') + '|');

  for (const req of requirements) {
    const weight = customWeights[req.id] ?? 1;
    const cells = [
      `${req.name} (w:${weight})`,
      ...vendorScores.map((vs) => {
        const score = vs.scores.find((s) => s.requirementId === req.id);
        return score ? `${score.score.toFixed(1)} (${score.confidence})` : '—';
      }),
    ];
    lines.push('| ' + cells.join(' | ') + ' |');
  }
  lines.push('');

  // Per-Vendor Breakdown
  lines.push('## Per-Vendor Breakdown');
  lines.push('');

  for (const vs of vendorScores) {
    lines.push(`### ${vs.vendor.name}`);
    lines.push('');
    lines.push(`- **Website:** ${vs.vendor.website}`);
    lines.push(`- **Overall Score:** ${vs.totalScore.toFixed(1)}/10`);
    lines.push(`- **Confidence:** ${vs.confidence}`);
    lines.push('');

    for (const req of requirements) {
      const score = vs.scores.find((s) => s.requirementId === req.id);
      if (!score) continue;

      lines.push(`#### ${req.name}`);
      lines.push(`Score: ${score.score.toFixed(1)}/10 | Confidence: ${score.confidence} | Freshness: ${score.freshnessLevel}`);
      lines.push('');

      const reqEvidence = evidence.filter(
        (e) => e.vendorId === vs.vendor.id && e.requirementId === req.id
      );

      if (reqEvidence.length > 0) {
        lines.push('Evidence:');
        for (const ev of reqEvidence) {
          lines.push(`- **${ev.claim}** (${ev.sourceType}, ${ev.strength}) — [Source](${ev.sourceUrl})`);
        }
        lines.push('');
      }
    }
  }

  // Methodology
  lines.push('## Methodology');
  lines.push('');
  lines.push('Scores are calculated using a weighted evidence-based system:');
  lines.push('- **Source weights:** Official Docs (1.0), GitHub (0.8), Blog (0.6), Community (0.4)');
  lines.push('- **Recency multiplier:** Fresh <90d (1.0), Aging 90-365d (0.85), Stale >365d (0.7)');
  lines.push('- **Strength multiplier:** Strong (1.0), Moderate (0.7), Weak (0.4)');
  lines.push('- **Confidence levels:** High (3+ strong official sources), Medium (mixed), Low (<2 items or all stale)');
  lines.push('');

  // Priority Weights
  lines.push('### Custom Priority Weights');
  lines.push('');
  for (const req of requirements) {
    lines.push(`- ${req.name}: **${customWeights[req.id] ?? 1}**/5`);
  }
  lines.push('');

  lines.push('---');
  lines.push('*Report generated by [SignalCore](https://signalcore.vercel.app)*');

  return lines.join('\n');
}

export function copyToClipboard(text: string): Promise<void> {
  return navigator.clipboard.writeText(text);
}

export function downloadMarkdown(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/markdown' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.click();
  URL.revokeObjectURL(url);
}
